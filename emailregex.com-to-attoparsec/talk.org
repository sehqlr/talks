#+TITLE: emailregex.com to Attoparsec: a walkthrough

#+OPTIONS: toc:nil
#+REVEAL_HLEVEL: 2
#+REVEAL_PLUGINS: (highlight notes)

#+MACRO: lambda  $$ (\lambda s.\!p)(s) $$ 
#+MACRO: mastodon  Mastodon: @sehqlr@mastodon.technology
#+MACRO: slack  stl-tech.slack.com: @sehqlr

* Preamble
  #+begin_src sh :eval never
    notmuch search --output=files --format=text0 tag:lists or from:meetup.com or from:lobste.rs | xargs -0 cat | grep '^From:.*@' | sort | uniq | cut -c7- > addresses.txt
  #+end_src

* Meetup Blurb                                                     :noexport:
  Regular expressions (regexes) are a common tool used by programmers to match
  strings and to do simple parsing. However, humans have trouble parsing regexes
  when they get complicated: emailregex.com, for example. What can you do when
  your regex gets too big? Parser Combinators, of course! In this talk, I will
  walk the audience through a reimplementation of emailregex.com in Attoparsec, a
  popular parser combinator library on Hackage, explaining how it works along the
  way.

  Sam Hatfield is a software developer living in St. Louis. For the last five
  years heâ€™s worked in a diverse set of domains including DevOps and Fullstack Web
  Development. His research interests include data science and formal methods.
* Opening
** emailregex.com
   Let's load up a saved version of the website with the ads removed

   #+begin_quote
   Email Address Regular Expression That 99.99% Works. Disagree? Join Discussion! 
   #+end_quote

   - The website says that it's powered by ZenBase, and they have a regex visualization tool alongside the regex itself
** the regex
   
   #+begin_src sh :results output verbatim :exports both
     fold ./emailregex.txt
   #+end_src

   #+RESULTS:
   : (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x0
   : 8\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:
   : (?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25
   : [0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?
   : |[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x
   : 09\x0b\x0c\x0e-\x7f])+)\])

   - This is 427 characters long, or six lines when line width is set to 80
   - This is just the groups: ~sed 's/[^()]//g' emailregex.txt~
** Why is it so complex?
   This email regex doesn't just include the kind of email address that you
   include in registration forms, like this one: =hey@samhatfield.me=

   This regex implements RFC5322, which is mentioned at the top of the website.

   The regex (and our reimplementation) has to be able to parse more...
   
   NOTE These are the =From= headers from my notmuch email database. I have
   searched for emails from mailing lists, meetup.com, and lobste.rs, to keep
   these limited to public sources.
     
   #+begin_example
   Sam H <samuel.e.hatfield@gmail.com>
   rebecca skinner <Haskell-Users-Group-St-Louis-announce@meetup.com>
   WU ICTS -  Health Informatics and Data Science Meetup <info@meetup.com>
   "0x70532007" <0x70532007@lobste.rs>
   #+end_example

* Walkthrough
** First, we need to parse the parser
   So, how do we reimplement this thing with Attoparsec? Let's walk thru a
   possible path together. Obviously, each reimplementation you may attempt in
   future are going to be their own particular journey.

   The very first thing we are NOT going to do is start at the beginning of the
   expression and start to try to implement each parser function, which was my
   first instinct. Instead, since we are following an ideal path, we are going
   to think about the patterns and strutures in this problem, and break the
   regex into subregexes, implement those into parser functions, then use the
   combinators to arrive at our solution

   but first, lets make this a little easier to read

   #+begin_src sh :results output verbatim :exports both
     cat ./emailregex.txt | sed 's/(?:/\n(?:/g'
   #+end_src

   #+RESULTS:
   #+begin_example

   (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+
   (?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"
   (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@
   (?:
   (?:[a-z0-9]
   (?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]
   (?:[a-z0-9-]*[a-z0-9])?|\[
   (?:
   (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
   (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:
   (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
   #+end_example
** Attoparsec basics
    at this time, i realized that there is one character that all email
    addresses have... =@=! and turns out that this is a great place to start
    with some attoparsec

    What is parser?
    What is combinator?

    at :: Parser Char
    at = char '@'

    parse at "@" 

** Regex metacharacters to Attoparsec parsers, part I
*** Match any single character
    * Regex :: =.= matches anything, including newlines sometimes
    * Attoparsec :: =anyChar :: Parser Char=
*** Match the end of line
    * Regex :: =$= matches the end of a line
    * Attoparsec :: =endOfLine :: Parser ()=
*** NOTE
    Since functions are now orthogonal to text data, there are no more
    metacharacters, and therefore, no more metacharacter escaping. If you want
    to match an opening square bracket, =char '['= is all you need! This will
    become important later
** Characters Classes and Capture Groups
*** Classes
    So, in regexes, there are character classes, delimited by square brackets,
    and capture groups, delimited by parentheses.
   
    As I looked at this thing, I noticed that there were a LOT of character
    classes, some of them for binary character codes, too. I thought that was
    odd.

    ASIDE: Did you know that Emacs doesn't seem to have a regex mode? Like,
    builtin, I mean. It has a regex builder, and uses regexes as function args
    EVERYWHERE, but there isn't an editor mode for them. Yet another reason why
    what I'm showing tonight is useful: your Haskell PCs are just Haskell.

    So, I decided to extract out all the character classes, deduplicate them,
    and see if I can understand their semantics
    
**** Alphanumeric-ish character classes
    So, the first three are *really* easy to translate, both syntactically and
    semantically. Attoparsec defines a function =inClass :: String -> Char ->
    Bool=. As you can see, it doesn't return a =Parser= type. I looked at the
    source, and it actually uses an unboxed =FastSet= type for performant
    membership testing. Since this library is meant for performance over
    everything else, there are little oddities... at least, that's what I tell
    myself.

    Back to the character class...
***** Match =a= to =z= and =0= to =9=
      * Regex :: =[a-z0-9]=
      * Attop :: =inClass "a-z0-9"=
***** Same as above, but with a hyphen
      * Regex :: =[a-z0-9-]=
      * Attop :: =inClass "a-z0-9-"=
***** Whatever this grabbag of characters is supposed to be
      * Regex :: =[a-z0-9!#$%&'*+/=?^_`{|}~-]=
      * Attop :: =inClass "a-z0-9!#$%&'*+/=?^_`{|}~-"=

**** interlude: start replacing formatted regex with Haskell
    #+begin_src haskell
    alnum :: Char -> Bool
    alnum = inClass
    {-
    (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+
    (?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"
    (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@
    (?:
    (?:[a-z0-9]
    (?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]
    (?:[a-z0-9-]*[a-z0-9])?|\[
    (?:
    (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
    (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:
    (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
    -}
    #+end_src

**** ASCII Control Code
    #+begin_example
    [\x01-\x09\x0b\x0c\x0e-\x7f] (*2) (A)
    [\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f] (B)
    [\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f] (C)
    #+end_example
***** binary stuff
      * Regex :: =[a-z0-9!#$%&'*+/=?^_`{|}~-]=
      * Attop :: =inClass "a-z0-9!#$%&'*+/=?^_`{|}~-"=

    

    A D == NL CR
    9 A D 20 22 5C == TAB NL CR Space " \
    9 A D 20 5C == TAB NL CR Space \


   
* Demo & comparison
** demo on finding email addresses in all my messages from meetup.com

** qualitative analysis
*** better comments
*** lexical binding -> modular code

* Closing
* Contact
  THANK YOU

  {{{mastodon}}}

  {{{slack}}}

  {{{email}}}

