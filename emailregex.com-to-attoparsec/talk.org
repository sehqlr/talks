#+TITLE: emailregex.com to Attoparsec: a walkthrough

#+OPTIONS: toc:nil
#+REVEAL_HLEVEL: 2
#+REVEAL_PLUGINS: (highlight notes)

#+MACRO: lambda  $$ (\lambda s.\!p)(s) $$ 
#+MACRO: mastodon  Mastodon: @sehqlr@mastodon.technology
#+MACRO: slack  stl-tech.slack.com: @sehqlr

* Preamble
  #+begin_src sh :eval never
    notmuch search --output=files --format=text0 tag:lists or from:meetup.com or from:lobste.rs | xargs -0 cat | grep '^From:.*@' | grep -vi '?utf' | sort | uniq | cut -c7- > addresses.txt
  #+end_src

* Meetup Blurb                                                     :noexport:
  Regular expressions (regexes) are a common tool used by programmers to match
  strings and to do simple parsing. However, humans have trouble parsing regexes
  when they get complicated: emailregex.com, for example. What can you do when
  your regex gets too big? Parser Combinators, of course! In this talk, I will
  walk the audience through a reimplementation of emailregex.com in Attoparsec, a
  popular parser combinator library on Hackage, explaining how it works along the
  way.

  Sam Hatfield is a software developer living in St. Louis. For the last five
  years heâ€™s worked in a diverse set of domains including DevOps and Fullstack Web
  Development. His research interests include data science and formal methods.
* Opening
** emailregex.com
   Let's load up a saved version of the website with the ads removed

   #+begin_quote
   Email Address Regular Expression That 99.99% Works. Disagree? Join Discussion! 
   #+end_quote

   - The website says that it's powered by ZenBase, and they have a regex visualization tool alongside the regex itself
** the regex
   
   #+begin_src sh :results output verbatim :exports both
     fold ./emailregex.txt
   #+end_src

   #+RESULTS:
   : (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x0
   : 8\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:
   : (?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25
   : [0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?
   : |[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x
   : 09\x0b\x0c\x0e-\x7f])+)\])

   - This is 427 characters long, or six lines when line width is set to 80
   - This is just the groups: ~sed 's/[^()]//g' emailregex.txt~
** Why is it so complex?
   This email regex doesn't just include the kind of email address that you
   include in registration forms, like this one: =hey@samhatfield.me=

   This regex implements RFC5322, which is mentioned at the top of the website.

   The regex (and our reimplementation) has to be able to parse more...
   
   NOTE These are the =From= headers from my notmuch email database. I have
   searched for emails from mailing lists, meetup.com, and lobste.rs, to keep
   these limited to public sources.
     
   #+begin_example
   Sam H <samuel.e.hatfield@gmail.com>
   rebecca skinner <Haskell-Users-Group-St-Louis-announce@meetup.com>
   WU ICTS -  Health Informatics and Data Science Meetup <info@meetup.com>
   "0x70532007" <0x70532007@lobste.rs>
   #+end_example

* Walkthrough
** First, we need to parse the parser
   So, how do we reimplement this thing with Attoparsec? Let's walk thru a
   possible path together. Obviously, each reimplementation you may attempt in
   future are going to be their own particular journey.

   The very first thing we are NOT going to do is start at the beginning of the
   expression and start to try to implement each parser function, which was my
   first instinct. Instead, since we are following an ideal path, we are going
   to think about the patterns and strutures in this problem, and break the
   regex into subregexes, implement those into parser functions, then use the
   combinators to arrive at our solution

** Characters Classes and Capture Groups
*** Classes
    So, in regexes, there are character classes, delimited by square brackets,
    and capture groups, delimited by parentheses.
   
    As I looked at this thing, I noticed that there were a LOT of character
    classes, some of them for binary character codes, too. I thought that was
    odd.

    ASIDE: Did you know that Emacs doesn't seem to have a regex mode? Like,
    builtin, I mean. It has a regex builder, and uses regexes as function args
    EVERYWHERE, but there isn't an editor mode for them. Yet another reason why
    what I'm showing tonight is useful: your Haskell PCs are just Haskell.

    So, I decided to extract out all the character classes, deduplicate them,
    and see if I can understand their semantics
    
    #+begin_example
    [a-z0-9!#$%&'*+/=?^_`{|}~-] (*2)
    [\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]
    [\x01-\x09\x0b\x0c\x0e-\x7f]
    [a-z0-9]
    [a-z0-9]
    [a-z0-9]
    [a-z0-9]
    [a-z0-9-]
    [a-z0-9-]
    [\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]
    [\x01-\x09\x0b\x0c\x0e-\x7f]
    #+end_example

   What is one thing that all email addresses have? =@=! That means we can now
   split this monster up into three parts, beforeAt, =@=, then afterAt.

   
* Demo & comparison
** demo on finding email addresses in all my messages from meetup.com
*** regex first
*** then atto

** qualitative analysis
*** better comments
*** lexical binding -> modular code

** quantitative/static analysis of source code??
** benchmarks??
* Closing
* Contact
  THANK YOU

  {{{mastodon}}}

  {{{slack}}}

  {{{email}}}

