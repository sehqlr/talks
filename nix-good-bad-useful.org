#+TITLE: Nix: The Good, The Bad, and The Useful

#+OPTIONS: toc:nil
#+REVEAL_HLEVEL: 2
#+REVEAL_PLUGINS: (highlight notes)

#+MACRO: lambda  $$ (\lambda s.\!p)(s) $$ 
#+MACRO: mastodon  Mastodon: @sehqlr@mastodon.technology
#+MACRO: slack  stl-tech.slack.com: @sehqlr
#+MACRO: myemail talks+nix@samhatfield.me

#+begin_src sh :session *nix repl* :exports none
nix repl '<nixpkgs>'
#+end_src

#+RESULTS:
| Welcome | to                 | Nix        | version | 2.2.2. | Type | :? | for | help. |
| '...    |                    |            |         |        |      |    |     |       |
| Added   | 10135              | variables. |         |        |      |    |     |       |
| echo    | 'org_babel_sh_eoe' |            |         |        |      |    |     |       |

* Meetup Blurb                                                     :noexport:
  In this talk, Sam will discuss Nix, the functional package manager. He will
  focus on the store (the good), the language (the bad), and how the tool and the
  greater Nix ecosystem can be leveraged to solve problems with polyglot systems
  (the useful).

  If you cannot be there in person, this talk will be recorded and available
  online.

* Hey Polyglots :)
** Why I wanted to give this talk
*** share the feelings
    I want to enthuse and vent about a useful thing I'm using and learning about

    I've been using it on and off for 3 years, and I haven't gotten bored yet
*** new kind of intro
    I want to try out a different approach to introduce Nix

    Others don't focus enough on the underlying theorhetical basis of the tech, imo
*** new conversations
    That's one of the best parts of Polyglots: our conversations

    And you aren't able to come in on person, let's talk online!

    {{{mastodon}}}

    {{{slack}}}

    {{{myemail}}}
** what I'll be talking about
   - What is Nix?
   - Nix Store, the Good
   - Nix Language, the Bad
   - Nix build system, the Useful
   - Nix ecosystem
   - Some conversation starters

* So, What *is* Nix?
** A "new" word
   #+begin_quote
   The name Nix is derived from the Dutch word _niks_, meaning _nothing_;
   build actions do not see anything that has not been explicitly declared as
   an input.

   -- "Nix: A Safe and Policy-Free System for Software Deployment", footnote 1
   #+end_quote
** an FP package manager
*** packages are the immutable outputs of pure functions
    {{{lambda}}}
    - $s$ is a specification of a package
    - $p$ is the resulting package
** FP DSL
   for specifing those packages

   Writing code in this language is
   #+ATTR_REVEAL: :frag highlight-red
   SPOILER ALERT
   #+ATTR_REVEAL: :frag roll-in
   the part I don't like
** an entire ecosystem
   - an operating system
   - DevOps tool(s)
   - declarative user configuration mgmt
   - and much more
** MY OPINION
   a breath of fresh air for
   - building
   - configuring
   - packaging
   software
** What it isn't
*** well documented
    The manuals are alright, but there are a lot of bad examples in the wider
    ecosystem
**** [[https://rycee.gitlab.io/home-manager/index.html][home-manager GitHub page]]
**** [[file:to-be-done.png][home-manager Darwin install section]] 

   #+REVEAL: split
   This isn't unique to Nix, *BUT* I wish I could recommend this as a tool, not
   an independent study
*** a good DSL
    SARCASM: Haskell and JSON had a baby, but can't agree on parenting styles

    #+REVEAL: split
    BTW, if there are any good arguments for anything I'm complaining about,
    talk to me

    Remember: opinions are like armpits. Everyone has one, and most of them stink
*** perfect 
    no software is perfect

    I said this project was a breath of fresh air.

    Well, fresh air has bad smells too
** Why is it worth talking about?
*** Unique approach
    Nix has a unique approach to package management, with many useful implications
**** all install, upgrade, and rollback operations are atomic
**** helps with difficult dependency management
**** share reproducible build envs in source and binary forms
**** sarcasm/ learn another DevOps system with terrible syntax /s
     no but really I like it
*** builds upon existing Unix technologies
**** default env is close to =build-essentials= in Debian
**** lots of CLI tools (that are included in the slides)
**** most CLI options are also configurable with env vars

* Nix Store, the Good  
  Motivation for learning the less good parts
** The "other" package managers
   The details here are very generalized, and for contrasting with Nix only
*** Filesystem Hierarchy Standard
    many different directories contain files for programs and configuration
**** In Ubuntu, the Emacs executable is installed at =/usr/bin/emacs25=
     [[file:ubuntu-emacs-package.png]]
     #+BEGIN_NOTES
     https://packages.ubuntu.com/bionic/amd64/emacs25/filelist
     #+END_NOTES
   #+REVEAL: split
**** Emacs elisp packages are installed in =~/.emacs.d=
**** Emacs config files are in =$HOME= or elsewhere
*** in-place changes
**** when emacs is updated, the data at =/usr/bin/emacs25= is overwritten
**** if the update process crashes or is interrupted, it could be in partial state
     many mechanisms prevent this, but Nix does it differently, as we shall see

*** MITM
    In order to make sure your package hasn't been compromised on its way to you
    by a MITM attack, you need to verify it with a cryptographic hashing process

    typically, you download the hash the server has, perform the hashing on your
    computer, then compare the two hashes to make sure they match

    Some package managers do this automatically, but some don't and you have to
    do it by hand
*** dependency management
    dependency management is a large part of what the package manager does, and
    when it goes wrong, your packages are broken

    When the best standard you have is =semver= and Firefox doesn't use it,
    you've got a hard job on your hands
*** CONCURRENT dep mgmt
    wow, is that impossible? How do you manage this?

    - =chroot=?
    - sandboxes?
    - DOCKER!?
    
    maybe this one reason is why every language has their package manager?
    
    ... and tools built on top? to manage concurrent versions?

** Nix Does It Different
   how it compares to "the others"
   #+name: dependencies
   #+begin_src sh :results value file :file dependencies.png :exports both
   nix-store -q --graph $(realpath $(which curl)) | dot -Tpng
   #+end_src

   #+RESULTS: dependencies
   [[file:dependencies.png]]

   #+BEGIN_NOTES
   The image for the Emacs dep graph was too big
   #+END_NOTES
   
*** CRYPTO ALL THE THINGS!
    Nix hashes *all* packages it builds, everytime it builds them, including
    their depedencies

    therefore,
    - the verification step and the build step are one and the same
    - changes to the package result in different hashes
    - every package has a unique ID based on its contents
    
*** =/nix/store=
    all packages that are built by nix go into this directory

    the directory template is =hash-name=, where hash is the hash from the build

    because every package has a unique name, Nix can store them side-by-side

    #+REVEAL: split
    #+begin_src sh :results value verbatim :exports both
    nix path-info nixpkgs.curl
    #+end_src

    #+RESULTS:
    : /nix/store/yb6s1k41s7sydr6q3nzmayhvbkzhydvf-curl-7.64.0-bin

*** Symlinked installs
   installs are done with symlinks from outside the store

   #+begin_src sh :results value verbatim :exports both
   ls -l $(which curl)
   #+end_src

   #+RESULTS:
   : lrwxrwxrwx 1 root root 68 Dec 31  1969 /run/current-system/sw/bin/curl -> /nix/store/nakc4z4vz69sq2jjlakp64s04qgggvja-curl-7.64.1-bin/bin/curl

   #+BEGIN_NOTES
   BTW, Nix resets all timestamps, that's why the file is so old
   #+END_NOTES

*** inside one of them
    within the package's directory, it is similar to current package archives
    #+begin_src sh :results output verbatim :exports results
    ls $(nix path-info nixpkgs.emacs)/*
    #+end_src

    #+RESULTS:
    #+begin_example
    /nix/store/8j5qqfk1qnz1mjw0z72ih336dzkpkl8w-emacs-26.1/bin:
    ctags
    ebrowse
    emacs
    emacs-26.1
    emacsclient
    etags

    /nix/store/8j5qqfk1qnz1mjw0z72ih336dzkpkl8w-emacs-26.1/lib:
    systemd

    /nix/store/8j5qqfk1qnz1mjw0z72ih336dzkpkl8w-emacs-26.1/libexec:
    emacs

    /nix/store/8j5qqfk1qnz1mjw0z72ih336dzkpkl8w-emacs-26.1/share:
    appdata
    applications
    emacs
    icons
    info
    man
    #+end_example

    #+BEGIN_NOTES
    the path-info command can bring up any attribute, not just current executables
    #+END_NOTES


** Derivations, the unit of composition
*** derivations: the outputs of the FP package system
**** [[https://nixos.org/nix/manual/#ssec-derivation][The description of what a derivation is]]
     derivations are a set of particular attributes

*** derivations can refer to other derivations (AKA dependencies)

**** dependency management
     a derivation uses the dep's cryptographic hash as the reference. This is
     similar to a Merkle DAG, but I've never seen this term in the docs
**** composition
     $$ g \circ f(x) $$

     Derivations are composed with their dependencies like docker image layers or photoshop layers

*** a derivation file
    surprise!
    #+ATTR_REVEAL: :frag roll-in
    it's JSON
    #+REVEAL: split
    #+BEGIN_NOTES
    I'm creating a subshell that has jq in the env, running it, to pretty-print
    the JSON of it's derivation. Are you not impressed??
    #+END_NOTES
     #+begin_src sh :results verbatim
     nix show-derivation nixpkgs.jq | nix-shell -p jq --run jq | head -n10
     #+end_src

     #+RESULTS:
     #+begin_example
     {
       "/nix/store/7g5n296kyk2n11bki54cwpn2n27x597z-jq-1.6.drv": {
         "outputs": {
           "bin": {
             "path": "/nix/store/czdpwxms57dqqv4vixcx6pg6xl8lmsjv-jq-1.6-bin"
           },
           "dev": {
             "path": "/nix/store/zbrd5iga16dagl99bkk8y354rxvsrpqg-jq-1.6-dev"
           },
           "doc": {
     #+end_example

** Further Implications
    
*** caching
    the store is a binary cache for everything already, and not just for your machine

*** installs, updates, and rollbacks are atomic (both small and discrete)
    because previous packages are still available when you build a new package,
    you can point a symlink to an old version easily.

    And because a symlink is
    completely descrete (it either points to another file or it doesn't)
    packaging actions are never in a partial state.

    #+BEGIN_NOTES
    LAPTOP WIFI STORY
    - happened this month
    - changing config to make my setup behave like a nixos module
    - made a change that didn't include networkmanager
    - before, I'd move the laptop to connect to the router via Ethernet
    - but this time, I realized that I could do a rollback
    - rebooted, selected the GRUB entry that I wanted, and BAM! Wifi works
    - that was it!
    - I fixed the config, tested this time, and was able to move forward without losing wifi again
    #+END_NOTES

*** deduplication of depdendencies
    if two different packages depdend upon the same hash, there will only be one
    copy in the store, and two symlinks pointing to it downstream

    #+NAME: PCRE2
    #+begin_src sh :results value verbatim :exports both
    nix-store -q --tree ~/.nix-profile | grep pcre2 
    #+end_src

    #+RESULTS:
    : |   |   |   |   |   |   +---/nix/store/z6yc6gz2sc18xwb9vrs0hkfsibm87b4l-pcre2-10.32
    : |   |   |   |   |   |   |   +---/nix/store/z6yc6gz2sc18xwb9vrs0hkfsibm87b4l-pcre2-10.32 [...]
    : |       +---/nix/store/z6yc6gz2sc18xwb9vrs0hkfsibm87b4l-pcre2-10.32 [...]
    : |   |   +---/nix/store/ryrjib7x67ddq5x65m1d16glay89wy06-pcre2-10.32
    : |   |   |   +---/nix/store/ryrjib7x67ddq5x65m1d16glay89wy06-pcre2-10.32 [...]
    : |   |   |   |   |   |   |   +---/nix/store/ryrjib7x67ddq5x65m1d16glay89wy06-pcre2-10.32 [...]
    : |   |   |   +---/nix/store/z6yc6gz2sc18xwb9vrs0hkfsibm87b4l-pcre2-10.32 [...]

    #+BEGIN_NOTES
    each line is a different symlink
    #+END_NOTES

*** concurrent dependencies for everything
    since all packages are stored concurrently, it means that many different
    versions of the same depdendency are available to many packages.

    #+CALL: PCRE2()

    #+RESULTS:
    : |   |   |   |   |   |   +---/nix/store/z6yc6gz2sc18xwb9vrs0hkfsibm87b4l-pcre2-10.32
    : |   |   |   |   |   |   |   +---/nix/store/z6yc6gz2sc18xwb9vrs0hkfsibm87b4l-pcre2-10.32 [...]
    : |       +---/nix/store/z6yc6gz2sc18xwb9vrs0hkfsibm87b4l-pcre2-10.32 [...]
    : |   |   +---/nix/store/ryrjib7x67ddq5x65m1d16glay89wy06-pcre2-10.32
    : |   |   |   +---/nix/store/ryrjib7x67ddq5x65m1d16glay89wy06-pcre2-10.32 [...]
    : |   |   |   |   |   |   |   +---/nix/store/ryrjib7x67ddq5x65m1d16glay89wy06-pcre2-10.32 [...]
    : |   |   |   +---/nix/store/z6yc6gz2sc18xwb9vrs0hkfsibm87b4l-pcre2-10.32 [...]

    #+BEGIN_NOTES
    two derivations:
    - z6yc6gz2...
    - ryrjib7x...
    #+END_NOTES

*** per-user, per-project package management, without sudo
    each user/project/whatever is itself a package, and is symlinked into your system
    #+begin_src sh :results value verbatim :exports both
    realpath ~/.nix-profile
    #+end_src

    #+RESULTS:
    : /nix/store/27z4bmv650idxr4az13a88fph7d94x2z-user-environment

    #+begin_notes
    all you'd need is a GUI for nix-env and you'd have a beginner-safe desktop
    app store for Linux, perhaps?
    #+end_notes

*** bad packages are isolated

**** malicious

**** poorly written 

*** reproducability
    [[https://r13y.com][Is NixOS Reproducible?]]

    This means that you can build a package, and then copy
    over the files to a different machine, and it would be the same as if that
    machine built the package.

*** content-addressability
    [[https://cachix.org][Cachix - Nix binary cache hosting]] 

    instead of computing a hash on something you downloaded to prove its valid,
    you can ask to download a valid package with the computed hash.

    
*** any program and uses files for configuration can be configured with Nix
    [[https://github.com/rycee/home-manager][=home-manager= GitHub project]]

    any file can be in the Store, and symlinks can put them wherever the
    program expects a file to be. 

    This is how =home-manager= works, generally speaking

* Nix Lang, the bad
** basic description

*** the common term for a program in this language is a "Nix Expression" or "nixexpr"
    In many parts of the documentation, it's referred to as the "Nix Expression Language"

    I'll be using the "nixexpr" term for the remainder of the talk

*** no specifying document that I could find
    - no formal grammar
    - no language specification

*** dynamically typed
    They use "strongly" typed in their description, but I agree with "What you
    need to know before debating type systems": "strongly" typed doesn't mean
    much of anything

*** lazy evaluated
    lazy eval is like putting stuff in an online shopping cart.

    You could have something in there for months, but until you actually pay
    for it, it won't show up at your door.

*** purely functional
    {{{lambda}}}

    no side-effects, only inputs and outputs, and outputs are completely
    dependent on inputs. Same inputs, same outputs

*** domain-specific
    nixexprs are ultimately for building packages, so the design is
    constrained on purpose.

** syntax & semantics
   AKA haskell vs Javascript/JSON
   https://nixos.org/nix/manual/#ch-expression-language
   
   #+begin_notes
   we'll go over value types and grammatical structures in parallel
   #+end_notes
** The unsurprising stuff
   These parts of the language very much look like either Haskell or
   Javascript/JSON, so I'm going to group them at the beginning, and get to the
   surprising stuff later
   
*** Numbers
**** ints: =-10000=
**** floating point: =123.5467e9=
**** operators: =+ * < >= =====

     Haskellers, you _won't_ be doing this:
     #+begin_src sh :session *nix repl* :results value verbatim
     map (+1) [1 1 1 1]
     #+end_src

     #+RESULTS:
     : error: syntax error, unexpected '+', at (string):1:6
     : echo 'org_babel_sh_eoe'

     #+BEGIN_NOTES
     Basic arithmetic, inequalities, and equality are the only math operations
     you will be performing in a nixexpr. You cannot pass operators as function
     values, you have to use the prefix function version, of which there are only
     add and multiply. This is a DSL dammit

     ALSO I'm using an org-babel session to evaluation the nix code since
     spacemacs doesn't have a nix repl feature that I'm aware of, so I guess the
     echo part is with us for the remainder of this trip
     #+END_NOTES

*** Booleans
**** literals: =true=, =false=

**** operators: =!== ==== =->=
     The arrow is logical implication, =!x || y=
     #+begin_src sh :session *nix repl* :results value verbatim
     true -> 1 < 3
     #+end_src

     #+RESULTS:
     : true
     : echo 'org_babel_sh_eoe'

*** =null=
    Also, =:t= is a REPL command that prints out the type of an expression, like
    in GHCi
    #+begin_src sh :session *nix repl* :results value verbatim
    :t null
    #+end_src

    #+RESULTS:
    : null
    : echo 'org_babel_sh_eoe'

** three kinds of strings
*** "" (double quotes)
    #+begin_src nix
      version = "3.2.1";
    #+end_src

    notice also that === is used for bindings, and that delimiting semicolon
     
    #+begin_notes
    I haven't quite figured out the exact rules for the semicolon

    AND if you use it where expected in the REPL it complains
    #+end_notes

    #+REVEAL: split
    ALSO ALSO, there's no description of how variables work exactly in Nixexprs

    I looked everywhere (in the documentation)

    #+BEGIN_NOTES
    So far, I know you can't lead them with numerals

    are you supposed to read about it in their source??
    #+END_NOTES
*** '' '' (indented)
    #+begin_src nix
      postInstall =
        ''
          mkdir $out/bin $out/etc
          cp foo $out/bin
          echo "Hello World" > $out/etc/foo.conf
        '';
    #+end_src

    This is used for config file templating, since the text is left-shifted but
    otherwise text alignment is preserved

    #+BEGIN_NOTES
    COMPLAINT: I don't know why, but the default indentation settings for
    =nix-mode= for my install of spacemacs is horrible. May be a source of my
    bias against the language, I can't objectively say.
    #+END_NOTES
*** unquoted URIs
    #+begin_src nix
    https://gitlab.com/sehqlr/talks
    #+end_src
*** ${} (antiquotation)
    replaces variables with their values (as long as it isn't =null=
    #+begin_src nix
      name = "my-awesome-package";
      version = "0.0.1";
      copyright =
        ''
          Version: ${name}-${version}
        '';
    #+end_src
*** comments are =#= for one line comments, =/* ... */= for multiline, ala JS
**** TODO screenshot from this? https://twitter.com/TheDailyShow/status/976862147761332231

     #+begin_src nix
      /*
        REPORTER: Hey, JSON, can you speak to why developers complain about
                  using you as a configuration language?
      */

      # JSON: I have no comments
     #+end_src

** Paths
*** / style
    similar to Unix paths. A slash is required.
    #+begin_src nix
    customPackage = import ./custom.nix;
    #+end_src
*** Converting strings to paths... WHY????
    #+begin_src nix
    absPath = /. + "/hello";
    relPath = ./. + "/hello";
    #+end_src

*** <> style (NIX_PATH is searched)
    #+begin_src nix
    let pkgs = import <nixpkgs> {};
        config = import <nixpkgs/modules> {};
    #+end_src
    This assumes a file called =default.nix= to be in the directory
** Lists
*** square brackets, no commas
    #+begin_src nix
    [ ]
    #+end_src
*** heterogenous
*** lazy in values, strict in length
    no infinite lists for you!
** Sets (the most important type!)
*** a collection of attributes wrapped in curly-braces
*** access members with =.= syntax
*** keys are either unquoted, or double-quoted
*** if key is =null= attr is dropped from set
*** if set has =__functor= it becomes callable
    Because this is Python-esque, and it sounds funny, I'm calling this a
    "dunder functor"
*** set theory operations
*** Recursive sets
    because sets aren't lazy enough??
    #+begin_src nix
    { x = y; y = 123; }.x #INVALID if y is not in scope outside of set
    rec {
      x = y;
      y = 123;
    }.x #VALID
    #+end_src
** functions
   NOTE: this was not included in the Values section in the docs even though
   this is an FP lang. Curious.
*** whitespace is function application
*** currying, partial application
*** two styles for args: lambda and set
**** lambda arg style
     #+begin_src nix
     id = x: x
     times = x: n: x * n
     #+end_src
       
***** common for classic FP patterns and overrides

**** set arg style

     #+begin_src nix
     { x, y, z }: x + y + z
     #+end_src
***** THE ONLY TIME COMMAS ARE USED
      WHY ON GODEL'S GREEN EARTH ARE THERE COMMAS HERE?!??!?!?
      [Terry Crews saying why dot gif]

***** variadic with =...=
      #+begin_src nix
      { config, pkgs, ... }: { ... }
      #+end_src

***** allows for default values
      #+begin_src nix
      { name ? "World", greeting ? "Hello" }: "${greeting}, ${name}!"
      #+end_src
        
** Keywords
    
*** =let in=
    lexical scoping, as in Haskell (but with semicolons!)
    #+begin_src nix
    let pkgs = import <nixpkgs> {};
    in
    { config, pkgs, ... }: { ... }
    #+end_src
*** =inherit=
    copy vars from the surrounding lexical scope, aka propogation

    #+REVEAL: split
    these two statements are equivalent
    #+begin_src nix
    inherit x y z;
    x = x; y = y; z = z;
    #+end_src

    #+REVEAL: split
    these two statements are equivalent
    #+begin_src nix
    inherit (src-set) a b c;
    a = src-set.a; b = src-set.b; c = src-set.c
    #+end_src
*** conditionals =if then else=

*** assertions
**** =assert e1; e2=

     =if e1 then e2 else abort=
**** logical implication, =e1 -> e2=
     =e1= /implies/ =e2=, or =!e1 || e2=
**** used together
     #+begin_src nix
     { httpd, httpServer ? false }: assert httpServer -> httpd != null;
     #+end_src

*** with expressions
    dynamic scoping, which I've read on the internet are bad, or good for you
    #+begin_src nix
    with builtins; map blah [blahs]
    #+end_src
** ergonomics

*** the "stdlib" from Nixpkgs

**** buildtins.*


*** nice: all the ecosystem runs on the lang
**** counterpoint: everything runs on JSON or YAML, so what
*** semicolons are not consistent
**** TODO because of assignment??
**** inside of let and with
**** not outside toplevel expressions
**** inside of sets
**** not inside lists

* Do we have other options? Sorta
  from least to most experimental
** {cabal,yarn,composer,...}2nix
    
*** reuse existing specifications to create nixexprs

*** is it proof that a language stinks when you compile to it?
** Guix and GuixSD
    
*** reimplimentation of nix

*** nix lang is replaced with Guile Scheme: Great! Lisp!
*** GuixSD is only Gnu approved software: Ummmmmm...
    If you hate systemd with a passion, this might be for you!
** dhall
*** total language
*** compiles to Nix, among other things
*** personally, this is the most interesting to learn

** expresso
*** new project
*** specifically designed with Nix in mind

* Nix build system, the useful
  #+begin_src sh :exports both :cache yes
     nix --version
  #+end_src

  #+RESULTS:
  : nix (Nix) 2.2.2
** segue: let's build the nixexpr!
   
*** nix build command(s)

*** result, user profiles
    user profile is like appending something to =$PATH=
** the build system a bit more in depth
*** creates a path to artifact mapping with symlinks
**** rollbacks
**** config mgmt
**** all the other implications from earlier

*** garbage collection
    preventing your whole disk from becoming the Nix store

** nixpkgs
   mentioning this in brief for time, this is a whole 'nother part of the ecosystem

*** github project for main repo
     
**** inclusion into nixpkgs is done via Issues and PRs
**** search and discovery are not great

     the most efficient search and discovery is from browsing the src
     directories

*** PPAs and similar can be added if narinfo file exists
    home-manager example

*** I miss AUR sometimes
    If Dhall was used as main config lang, then pkgs could be hosted on IPFS

** crunchbang headers for sandboxing one-off scripts

* The Nix Ecosystem
  Lets take a brief tour of the larger ecosystem built on this system

** official parts
*** NixOS
**** not the best desktop os, I suppliment my package management with AppImage and Flatpak
*** NixOps
*** Disnix
*** Hydra

** beyond
*** home-manager
*** lorri
*** cachix
*** static nix

* Conclusions
** lang sux, maybe use Dhall??
** build system rox
** store slaps
** maybe this tool can help you today
* Contact
  {{{mastodon}}}

  {{{slack}}}

  {{{myemail}}}

* Research                                                         :noexport:
** https://www.youtube.com/watch?v=D5Gq2wkRXpU
   
*** this covers the whole ecosystem, 1:23 duration

*** audience interaction
*** Intro to Nix
**** the big idea: FP has taught the world that global mutable state is bad, mkay?
**** problems with current state of affairs
***** in-place mutation (pkg installs) cannot be undone, hard to trace, etc...
***** dependencies (diamond inheritance problem)
***** unintended breakages
***** not composable
***** Ansible et al can drift
***** testing/QA is difficult for packaging
**** solution: "don't do that"
     This is not great! I'm really happy that I'm going to talk about the Nix
     store separately.
***** deterministic, isolated, timeless (all files are fixed at UNIX epoch)
***** no globals / immutable env
***** dependencies are only accessible via content-address
***** nix user profile
***** diamond problem
      I'd argue that the diamond problem does come up, it's a compilation error
***** nix has sandboxing all the down to the kernel
**** implications
***** dependencies are completely separated
***** declarative defs are idempotent, easily version controlled
***** changes/upgrades are non-destructive, atomic
***** always rolled back (generations)
**** aside: garbage collector
**** example
***** no windows!
***** works along-side other package managers
***** nix-shell explaination fumble
***** graphiz of git deps
**** nixpkgs
***** channels
***** https://howoldis.herokuapp.com
***** looking at github repo
**** nix lang
***** strongly, dynamically typed
***** lazy evaluation
***** immutable, pure FP
***** types
****** numbers (no floating point)
****** bools
****** strings
******* special multiline
******* interpolation
****** hetero lists
****** sets
******* . accessor
****** control
******* if/then/else expressions
******* =let ... in= lexical scoping
******* imports
******* =with= dynamic scoping
******* =x: x= function def, with currying and partial application
******* ={ x, y, z }: x + y + z= preferred syntax
**** let's build hello world
***** lots of stuff about working with haskell pkgs
***** example is a bash script that echo's hello world
***** more haskell examples
***** bad override example!!!!
      ugh, so much hand-waving
**** NixOps taster
*** this did not cover the whole ecosystem
** https://pdfs.semanticscholar.org/ac40/f3ace70c447ceb3415228899eb240892af79.pdf?_ga=2.94060181.929323198.1555963281-357808856.1555963281
*** footnote 1 quote
