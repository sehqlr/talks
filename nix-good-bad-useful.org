#+TITLE: Nix: The Good, The Bad, and the Useful

#+OPTIONS: toc:1
#+REVEAL_HLEVEL: 2
#+REVEAL_PLUGINS: (highlight notes)

#+MACRO: lambda  $$ (\lambda s.\!p)(s) $$ 

* Meetup Blurb                                                     :noexport:
  In this talk, Sam will discuss Nix, the functional package manager. He will
  focus on the store (the good), the language (the bad), and how the tool and the
  greater Nix ecosystem can be leveraged to solve problems with polyglot systems
  (the useful).

  If you cannot be there in person, this talk will be recorded and available
  online.

* Introduction
  Hey y'all
** Why I wanted to give this talk
*** I want to enthuse and vent about a useful thing I'm using and learning about
    I've been using it on and off for 3 years, and I haven't gotten bored yet
*** I want to try out a different approach to introduce Nix
    Others don't focus enough on the underlying theorhetical basis of the tech, imo
*** I want to talk to more people about it
    That's one of the best parts of Polyglots: our conversations
** So, What is Nix?
*** A "new" word
    #+begin_quote
    The name Nix is derived from the Dutch word _niks_, meaning _nothing_;
    build actions do not see anything that has not been explicitly declared as
    an input.

    -- "Nix: A Safe and Policy-Free System for Software Deployment", footnote 1
    #+end_quote
*** an FP package manager
**** packages are the immutable outputs of pure functions
     {{{lambda}}}
     - $s$ is a specification of a package
     - $p$ is nix package
*** FP DSL for specifing how those packages are built
    SPOILER ALERT
    #+ATTR_REVEAL: :frag roll-in
    This is the part I don't like
*** an entire ecosystem
    - an operating system
    - DevOps tool(s)
    - declarative user configuration mgmt
    - and much more
*** MY OPINION
    a breath of fresh air for building, configuring, and packaging software
** What it isn't
*** well documented
    The manuals are alright, but there are a lot of bad examples in the wider ecosystem
*** a good DSL
    We're going to get into it, promise
*** perfect 
    hey, fresh air has bad smells too
** Why is it worth talking about?
*** Nix has a unique approach to package management, with many useful implications
**** all install, upgrade, and rollback operations are atomic
**** helps with difficult dependency management
**** share reproducible build envs in source and binary forms
**** learn another DevOps system with terrible syntax /s
*** builds upon existing Unix technologies
**** the default env is very close to =build-essentials= in Debian

* Nix Store, the Good  
  Motivation for learning the less good parts
** =/usr/local/bin=, =./node_modules=, ...
   This is a generalized look at other package managers

   The details here are for contrasting with Nix only
*** many different directories contain files for programs and configuration
**** In Ubuntu, the Emacs executable is installed at =/usr/bin/emacs25=
     (https://packages.ubuntu.com/bionic/amd64/emacs25/filelist)
**** Emacs elisp packages are installed in =~/.emacs.d=
**** Emacs config files are in =$HOME= or elsewhere
*** when installing or upgrading a package, these directories' contents are changed
**** when emacs is updated, the data at

*** verifying a package requires crypographic hashing of that data as a separate step
*** dependency management is a large part of what the package manager does, and when it goes wrong, your packages are broken

** =/nix/store=
   #+name: dependencies
   #+begin_src sh :results value file :file dependencies.png
   nix-store -q --graph ~/.nix-profile | dot -Tpng
   #+end_src

   #+RESULTS: dependencies
   [[file:dependencies.png]]


*** unique directories, symlinked to expected paths
    all packages that are built and installed via nix go into this directory
    with their own unique path
**** every package has a unique directory. No updates, only additions
**** files within the store are symlinked to the rest of your system, and that is how they are installed
**** dependencies are symlinked within the store, so no package is stored more than once
**** in terms of data structures, this is similar to a hashtable

*** packages, AND THEIR DEPENEDNECIES, are cryptographically hashed as part of creating the unique directory
    therefore, the hashing step and the build step are one and the same
    
**** within the package's directory, it is similar to current package archives
     #+begin_src sh :results output verbatim :cache yes
     ls $(nix path-info nixpkgs.emacs)/*
     #+end_src

     #+RESULTS:
     #+begin_example
     /nix/store/8j5qqfk1qnz1mjw0z72ih336dzkpkl8w-emacs-26.1/bin:
     ctags
     ebrowse
     emacs
     emacs-26.1
     emacsclient
     etags

     /nix/store/8j5qqfk1qnz1mjw0z72ih336dzkpkl8w-emacs-26.1/lib:
     systemd

     /nix/store/8j5qqfk1qnz1mjw0z72ih336dzkpkl8w-emacs-26.1/libexec:
     emacs

     /nix/store/8j5qqfk1qnz1mjw0z72ih336dzkpkl8w-emacs-26.1/share:
     appdata
     applications
     emacs
     icons
     info
     man
     #+end_example


** Derivations, the unit of composition
*** derivations: the outputs of the FP package system
**** a derivation is "a package build action" (https://nixos.org/nix/manual/#idm140737318496688)
**** derivations are a set of particular attributes

*** derivations can refer to other derivations (AKA dependencies)

**** dependency management
     a derivation uses the dep's cryptographic hash as the reference. This is
     similar to a Merkle DAG, but I've never seen this term in the docs
**** composition
     derivation : package :: =f= : =g . f= :: docker image layer : docker image :: photoshop
     layer : photoshop file 

*** The derivative file format
**** surprise, it's JSON
     #+begin_src sh :results verbatim :cache yes
     nix show-derivation nixpkgs.jq | nix-shell -p jq --run jq
     #+end_src

     #+RESULTS:
     #+begin_example
     {
       "/nix/store/g85h9v9ni77w01j1hkmq6qw2dszhfnys-hello-2.10.drv": {
         "outputs": {
           "out": {
             "path": "/nix/store/5blzqmi4735d90rdrw26byjnn2bdzm4b-hello-2.10"
           }
         },
         "inputSrcs": [
           "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
         ],
         "inputDrvs": {
           "/nix/store/0si75icim8ajxcsp25d9c52m42kqg1xj-stdenv-linux.drv": [
             "out"
           ],
           "/nix/store/1kircip4wskspsqqzxbmh6ss73iqh9ah-bash-4.4-p23.drv": [
             "out"
           ],
           "/nix/store/5ngv9cppchx06n4ycxs2h127ffbykn1s-hello-2.10.tar.gz.drv": [
             "out"
           ]
         },
         "platform": "x86_64-linux",
         "builder": "/nix/store/cinw572b38aln37glr0zb8lxwrgaffl4-bash-4.4-p23/bin/bash",
         "args": [
           "-e",
           "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
         ],
         "env": {
           "buildInputs": "",
           "builder": "/nix/store/cinw572b38aln37glr0zb8lxwrgaffl4-bash-4.4-p23/bin/bash",
           "configureFlags": "",
           "depsBuildBuild": "",
           "depsBuildBuildPropagated": "",
           "depsBuildTarget": "",
           "depsBuildTargetPropagated": "",
           "depsHostHost": "",
           "depsHostHostPropagated": "",
           "depsTargetTarget": "",
           "depsTargetTargetPropagated": "",
           "doCheck": "1",
           "doInstallCheck": "",
           "name": "hello-2.10",
           "nativeBuildInputs": "",
           "out": "/nix/store/5blzqmi4735d90rdrw26byjnn2bdzm4b-hello-2.10",
           "outputs": "out",
           "propagatedBuildInputs": "",
           "propagatedNativeBuildInputs": "",
           "src": "/nix/store/3x7dwzq014bblazs7kq20p9hyzz0qh8g-hello-2.10.tar.gz",
           "stdenv": "/nix/store/63karsgdg7fm3q0if4zfd7apbd8ac1ci-stdenv-linux",
           "strictDeps": "",
           "system": "x86_64-linux",
           "version": "2.10"
         }
       }
     }
     #+end_example

** Implications
    
*** concurrent dependencies for everything
    since all packages are stored concurrently, it means that many different
    versions of the same depdendency are available to many packages. Have your
    Python 2 and 3 cakes side by side and eat them separately!

*** deduplication of depdendencies
    if two different packages depdend upon the same hash, there will only be one
    copy in the store, and two symlinks pointing to it from the downstream
    packages

*** per-user, per-project package management, without sudo
    symlinks can have different permissions than their targets

*** reproducability
    as long as the Nix build system performs deterministic builds, the same
    derivation should produce the same package directory, regardless of time or
    physical machine. This means that you can build a package, and then copy
    over the files to a different machine, and it would be the same as if that
    machine built the package.
*** caching
    the store is effectively a cache already
*** content-addressability
    instead of computing a hash on something you downloaded to prove its valid,
    you can ask to download a valid package with the computed hash.
*** installs, updates, and rollbacks are atomic (both small and discrete)
    because previous packages are still available when you build a new package,
    you can point a symlink to an old version easily. And because a symlink is
    completely descrete (it either points to another file or it doesn't)
    packaging actions are never in a partial state.
*** any program and uses files for configuration can be configured with Nix
    any file can be in the Store, and symlinks can put them whereever the
    program expects a file to be. So, configuration management has many of the
    same implications of atomic updates
* Nix Lang, the bad
** TODO nix-repl :session in src-blocks??
** basic description

*** the common term for a program in this language is a "Nix Expression" or "nixexpr"
    In many parts of the documentation, it's referred to as the "Nix Expression Language"

    I'll be using the "nixexpr" term for the remainder of the talk

*** SARCASM: Haskell and JSON had a baby, but can't agree on parenting styles
*** basic properties
    there is no formal grammar that I could find online, so we'll just list the features
**** strongly, dynamically typed
     type errors at runtime
     [wait for everyone's internal screaming to die down]
     like, either, you want a better type system, less of a type system, or you
     don't understand what the big deal is.
**** everything is an expression
     except for language contruct keywords, but /cest la vie/
     /la vie!/
**** lazy evaluation
     computation is often deferred until a value is needed
***** if you aren't familiar with lazy eval...
      it's like logical short-circuiting in C but for _all_ values
**** purely functional
     no side-effects, only inputs and outputs, and outputs are completely
     dependent on inputs. Same inputs, same outputs
**** domain-specific
     nixexprs are ultimately for building packages, so the design is
     constrained on purpose.
** syntax & semantics AKA haskell vs Javascript/JSON
   https://nixos.org/nix/manual/#ch-expression-language
   
*** grammatical structures

**** bindings are ===
     #+begin_src nix
       foo = bar
     #+end_src

**** comments are =#= for one line comments, =/* ... */= for multiline, ala JS
***** TODO screenshot from this? https://twitter.com/TheDailyShow/status/976862147761332231

      #+begin_src nix
       /*
         REPORTER: Hey, JSON, can you speak to why developers complain about
                   using you as a configuration language?
       */

       # JSON: I have no comments
      #+end_src

**** semi-colons delimit expressions ( sometimes ) (JS)
     It seems that you need one anytime you are binding to symbols, except in
     the repl, which throws errors for top-level bindings
**** indentation is not significant, except for indented strings
     COMPLAINT: I don't know why, but the default indentation settings for
     =nix-mode= for my install of spacemacs is horrible. May be a source of my
     bias against the language, I can't objectively say.
*** Values
**** Simple Values
***** Strings
****** three kinds
******* "" (same as Haskell and JSON)
        #+begin_src nix
          version = "3.2.1";
        #+end_src
******* '' '' (indented)
        #+begin_src nix
          postInstall =
            ''
              mkdir $out/bin $out/etc
              cp foo $out/bin
              echo "Hello World" > $out/etc/foo.conf
            '';
        #+end_src

******* unquoted URIs
****** ${} (antiquotation)
       #+begin_src nix
         name = "pop-culture-reference";
         version = "${name}-1997";
         copyright =
           ''
             Version: ${version}
           '';
       #+end_src

***** Numbers
      very much the same as Haskell and JSON
****** ints: =1=, =-10000=
****** floating point: 
***** Paths
****** / style
       similar to Unix paths. A slash is required.
       #+begin_src nix
       customPackage = import ./custom.nix;
       #+end_src
******* Converting strings to paths... WHY????
        #+begin_src nix
        absPath = /. + "/hello";
        relPath = ./. + "/hello";
        #+end_src

****** <> style (NIX_PATH is searched)
       #+begin_src nix
       let pkgs = import <nixpkgs> {};
           config = import <nixpkgs/modules> {};
       #+end_src
       This assumes a file called =default.nix= to be in the directory
***** Booleans: =true=, =false=
***** Null is =null=
      aside: is not antiquotable
**** Lists
***** heterogenous
***** no commas needed
***** lazy in values, strict in length
      no infinite lists for you!
**** Sets (the most important type!)
***** a collection of attributes
***** wrapped in curly-braces
***** access members with =.= syntax
***** keys are either unquoted, or double-quoted
***** if key is =null= attr is dropped from set
***** if set has =__functor= it becomes callable
      Because this is Python-esque, and it sounds funny, I'm calling this a
      "dunder functor"
***** set theory operations
**** functions
     NOTE: this was not included in the Values section in the docs even though
     this is an FP lang. Curious.
***** whitespace is function application
***** curried
***** partial application
***** two styles for args: lambda and set
****** lambda arg style
       #+begin_src nix
       id = x: x
       times = x: n: x * n
       #+end_src
       
******* common for classic FP patterns and overrides

****** set arg style

       #+begin_src nix
       { x, y, z }: x + y + z
       #+end_src
******* THE ONLY TIME COMMAS ARE USED
        WHY ON GODEL'S GREEN EARTH ARE THERE COMMAS HERE?!??!?!?
        [Terry Crews saying why dot gif]

******* variadic with =...=
        #+begin_src nix
        { config, pkgs, ... }: { ... }
        #+end_src

******* allows for default values
        #+begin_src nix
        { name ? "World", greeting ? "Hello" }: "${greeting}, ${name}!"
        #+end_src
        
**** TODO compare with other language specifications

*** Language Contructs
    
**** Recursive sets
     because sets aren't lazy enough??
     #+begin_src nix
     { x = y; y = 123; }.x #INVALID if y is not in scope outside of set
     rec {
       x = y;
       y = 123;
     }.x #VALID
     #+end_src
**** let-expressions (Haskell)
     lexical scoping, as in Haskell (but with semicolons!)
     #+begin_src nix
     let pkgs = import <nixpkgs> {};
     in
     { config, pkgs, ... }: { ... }
     #+end_src
**** inheriting attrs
     copy vars from the surrounding lexical scope, aka propogation
     #+begin_src nix
     inherit x y z;
     x = x; y = y; z = z;
     #+end_src

     #+begin_src nix
     inherit (src-set) a b c;
     a = src-set.a; b = src-set.b; c = src-set.c
     #+end_src
**** conditionals =if then else=

**** assertions
***** =assert e1; e2=

      =if e1 then e2 else abort=
***** logical implication, =e1 -> e2=
      =e1= /implies/ =e2=, or =!e1 || e2=
***** used together
      #+begin_src nix
      { httpServer ? false }: assert httpServer -> httpd != null;
      #+end_src

**** with expressions
     dynamic scoping, which I've read on the internet are bad, or good for you
     #+begin_src nix
     with builtins; map blah [blahs]
     #+end_src
** ergonomics

*** the "stdlib" from Nixpkgs

**** buildtins.*

***** 

*** nice: all the ecosystem runs on the lang
**** counterpoint: everything runs on JSON or YAML, so what
*** semicolons are not consistent
**** TODO because of assignment??
**** inside of let and with
**** not outside toplevel expressions
**** inside of sets
**** not inside lists

** Do we have other options? Sorta
*** TODO write nixexprs to load these into env??
*** Guix and GuixSD
    
**** reimplimentation of nix

**** nix lang is replaced with Guile Scheme: Great! Lisp!
**** GuixSD is only Gnu approved software: Ummmmmm...
     If you hate systemd with a passion, this might be for you!
*** expresso
**** new project
**** specifically designed with Nix in mind

*** dhall
**** total language
**** compiles to Nix
**** personally, this is the most interesting to learn

*** {cabal,yarn,composer,...}2nix
    
**** reuse existing specifications to create nixexprs

**** is it proof that a language stinks when you compile to it?
* Nix build system, the useful
  #+begin_src sh :exports both :cache yes
     nix --version
  #+end_src

  #+RESULTS:
  : nix (Nix) 2.2.2
** segue: let's build the nixexpr!
   
*** nix build command(s)

*** result, user profiles
    user profile is like appending something to =$PATH=
** the build system a bit more in depth
*** creates a path to artifact mapping with symlinks
**** rollbacks
**** config mgmt
**** all the other implications from earlier

*** garbage collection
    preventing your whole disk from becoming the Nix store
*** nixpkgs
    mentioning this in brief for time, this is a whole 'nother part of the ecosystem

**** github project for main repo
     
***** inclusion into nixpkgs is done via Issues and PRs
***** search and discovery are not great

      the most efficient search and discovery is from browsing the src
      directories

**** PPAs and similar can be added if narinfo file exists
     home-manager example

**** I miss AUR sometimes
     If Dhall was used as main config lang, then pkgs could be hosted on IPFS

** crunchbang headers for sandboxing one-off scripts

* the ecosystem that builds on this                
  Lets take a brief tour of the larger ecosystem built on this system

*** official parts
**** NixOS
***** not the best desktop os, I suppliment my package management with AppImage and Flatpak
**** NixOps
**** Disnix
**** Hydra
*** beyond
**** home-manager
**** lorri

* Conclusions
** lang sux, maybe use Dhall??
** build system rox
** store slaps
** maybe this tool can help you today

* Research                                                         :noexport:
** https://www.youtube.com/watch?v=D5Gq2wkRXpU
   
*** this covers the whole ecosystem, 1:23 duration

*** audience interaction
*** Intro to Nix
**** the big idea: FP has taught the world that global mutable state is bad, mkay?
**** problems with current state of affairs
***** in-place mutation (pkg installs) cannot be undone, hard to trace, etc...
***** dependencies (diamond inheritance problem)
***** unintended breakages
***** not composable
***** Ansible et al can drift
***** testing/QA is difficult for packaging
**** solution: "don't do that"
     This is not great! I'm really happy that I'm going to talk about the Nix
     store separately.
***** deterministic, isolated, timeless (all files are fixed at UNIX epoch)
***** no globals / immutable env
***** dependencies are only accessible via content-address
***** nix user profile
***** diamond problem
      I'd argue that the diamond problem does come up, it's a compilation error
***** nix has sandboxing all the down to the kernel
**** implications
***** dependencies are completely separated
***** declarative defs are idempotent, easily version controlled
***** changes/upgrades are non-destructive, atomic
***** always rolled back (generations)
**** aside: garbage collector
**** example
***** no windows!
***** works along-side other package managers
***** nix-shell explaination fumble
***** graphiz of git deps
**** nixpkgs
***** channels
***** https://howoldis.herokuapp.com
***** looking at github repo
**** nix lang
***** strongly, dynamically typed
***** lazy evaluation
***** immutable, pure FP
***** types
****** numbers (no floating point)
****** bools
****** strings
******* special multiline
******* interpolation
****** hetero lists
****** sets
******* . accessor
****** control
******* if/then/else expressions
******* =let ... in= lexical scoping
******* imports
******* =with= dynamic scoping
******* =x: x= function def, with currying and partial application
******* ={ x, y, z }: x + y + z= preferred syntax
**** let's build hello world
***** lots of stuff about working with haskell pkgs
***** example is a bash script that echo's hello world
***** more haskell examples
***** bad override example!!!!
      ugh, so much hand-waving
**** NixOps taster
*** this did not cover the whole ecosystem
** https://pdfs.semanticscholar.org/ac40/f3ace70c447ceb3415228899eb240892af79.pdf?_ga=2.94060181.929323198.1555963281-357808856.1555963281
*** footnote 1 quote

